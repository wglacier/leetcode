## C++
```c++
// 4ms, 100%
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <algorithm>
#include <climits>
#include <set>
#include <tuple>

using namespace std;

class Solution {
public:
    bool isMatch(string s, string p) {
        if (p.empty())
            return s.empty();

        vector<vector<bool>> dp(s.size()+1, vector<bool>(p.size()+1, false));
        dp[0][0] = true;
        if (!s.empty())
            dp[1][1] = p[0] == '.' || p[0] == s[0];

        for (int j = 2; j <= p.size(); j++) {
            // special cases, second char in p is '*', like 'a*b*c*' can match ''
            dp[0][j] = p[j-1] == '*' && dp[0][j-2];

            for (int i = 1; i <= s.size(); i++) {
                if (p[j-1] != '*') {
                    dp[i][j] = dp[i-1][j-1]
                        && (p[j-1] == '.' || s[i-1] == p[j-1]);
                } else {
                    dp[i][j] = dp[i][j-2]   // match 0 time
                        // || dp[i][j-1]
                        || (dp[i-1][j]
                             && (p[j-2] == '.' || s[i-1] == p[j-2]));
                }
            }
        }
        return dp[s.size()][p.size()];
    }
};

int main(int argc, char* argv[]) {
vector<tuple<string,string,bool>> v = {
    {"aa", "a", false},
    {"a", "a", true},
    {"", "a*", true},
    {"", "ABC", false},
    {"abc", "abcd", false},
    {"abc", "babc", false},
    {"abc", ".*abc", true},
    {"abc", ".*bc", true},
    {"abc", ".*c", true},
    {"abc", ".*", true},
    {"abc", "a*b*c*", true},
    {"abc", "a*b*c", true}
};
    for (auto a : v) {
        bool r = Solution().isMatch(get<0>(a), get<1>(a));
        if (r != get<2>(a)) {
            cout << "error: " << get<0>(a) << ' '  << get<1>(a) << ' ' << r << ", expected: " << get<2>(a) << endl;
        }
    }
    return 0;
}
```

```c++
class Solution {
private:
    bool match(string s, int i, string p, int j) {
        
        // both string end
        if (i == s.size() && j == p.size())
            return true;
    
        auto idx = p.find_first_of(".*", j);
        if (idx == string::npos) {
            if (i >= s.size()) return false;
            return s.substr(i) == p.substr(j);
        }
        if (p[idx] == '*') {
            if (idx < 1) return false;
            
            // compare the first few plain chars before pos('*') - 1
            while (j < idx - 1) {
                if (i == s.size()) return false;
                if (s[i] != p[j]) return false;
                i++, j++;
            }
            // * acts as 0 time
            if (match(s, i, p, idx + 1)) return true;
            
            // * acts as 1+ times
            if (i == s.size()) return false;
            if (s[i] != p[idx - 1]) return false;
            return match(s, i + 1, p, idx - 1);
        }
        
        // is a '.'
        // comare chars before '.'
        while (j < idx) {
            if (i == s.size()) return false;
            if (s[i] != p[j]) return false;
            i++, j++;
        }
        // no '*' immediately after '.'?
        if (idx == p.size() - 1 || p[idx+1] != '*') {
            if (i == s.size()) return false;
            return match(s, i + 1, p, idx + 1);
        }
        // is ".*" form
        // ".*" acts as 0 time
        if (match(s, i, p, idx + 2)) return true;
        
        // as 1+ times
        if (i == s.size()) return false;
        return match(s, i + 1, p, idx);
    }
    
public:
    bool isMatch(string s, string p) {
        return match(s, 0, p, 0);
    }
};
```